package main

import (
    "crypto/elliptic"
    "crypto/rand"
    "fmt"
"encoding/hex"


)

func GenerateRandomBytes(n int) ([]byte, error) {
    b := make([]byte, n)
    _, err := rand.Read(b)
    // Note that err == nil only if we read len(b) bytes.
    if err != nil {
        return nil, err
    }

    return b, nil
}



func main() {

c := elliptic.P256()

//flag.Parse()

//args := flag.Args()

//i,_:=strconv.Atoi(args[0])
i:=5

if ( i==1) {
    c = elliptic.P224() 
} else if (i==2) { 
    c = elliptic.P256() 
} else if (i==3) { 
    c = elliptic.P384() 
} else if (i==4) { 
    c = elliptic.P521() 
  
}

params := c.Params()

fmt.Printf("Type=%s\n\nP=%d\nN=%d\nB=%d\nGx=%d\nGy=%d\n\nField size=%d\n",params.Name,params.P,params.N,params.B,params.Gx,params.Gy,params.BitSize)


r,_ := GenerateRandomBytes(32)



p1x,p1y := c.ScalarMult(params.Gx,params.Gy,r)


fmt.Printf("\nPrivate key (n):\t%s\n",hex.EncodeToString(r))

fmt.Printf("\nPublic key point\nPx=%d\nPy=%d",p1x,p1y)


fmt.Printf("\nIs on curve: %t",c.IsOnCurve(p1x,p1y))


r1,_ := GenerateRandomBytes(32)


p2x,p2y := c.ScalarMult(params.Gx,params.Gy,r1)
// We could also use p2x,p2y := c.ScalarBaseMult(r)
 
p3x,p3y := c.Add(p1x,p1y,p2x,p2y)


fmt.Printf("\n=======\n\nAnother point:\nPx=%d\nPy=%d",p2x,p2y)

fmt.Printf("\n\nPoints added\nPx=%d\nPy=%d",p3x,p3y)


fmt.Printf("\nIs on curve: %t",c.IsOnCurve(p3x,p3y))


p4x,p4y := c.Double(p1x,p1y)
fmt.Printf("\n\n======\nPublic key point doubled\nPx=%d\nPy=%d",p4x,p4y)
fmt.Printf("\nIs on curve: %t",c.IsOnCurve(p4x,p4y))
fmt.Println("\nInitial x: ", p4x, "\n")
fmt.Println("Initial y: ", p4y)
fmt.Println("\nNegated Initial x: ", p4x.Neg(p4x), "\n")
fmt.Println("Negated Initial y: ", p4y.Neg(p4y))
fmt.Println("\n Updated values x and y:",p4x," ",p4y)
fmt.Printf("\nIs on curve (with Negative values): %t",c.IsOnCurve(p4x,p4y),"\n")
}
